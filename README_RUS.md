# Data_structures

Предметная область: Безопасность в сфере государственной службы.

1. Блок linked lists.
2. Блок stack.
3. Блок очередей.
4. Блок hash.
5. Блок рекурсия.
6. Блок инкапсуляция.
7. Блок наследования.
8. Блок полиморфизма.

## Оглавление

1. [Блок linked lists](#блок-linked-lists)\
    1.1 [Задание 1. Блок linked lists. Код](#задание-1-блок-linked-lists-код)\
    1.2 [Задание 2. Блок linked lists. Код](#задание-2-блок-linked-lists-код)\
    1.3 [Задание 3. Блок linked lists. Код](#задание-3-блок-linked-lists-код)\
    1.4 [Задание 4. Блок linked lists. Код](#задание-4-блок-linked-lists-код)\
    1.5 [Задание 5. Блок linked lists. Код](#задание-5-блок-linked-lists-код)
2. [Блок stack](#блок-stack)\
    2.1 [Задание 1. Блок stack](#задание-1-блок-stack)\
        2.1.1 [Задание 1. Блок stack. Теория](#задание-1-блок-stack-теория)\
        2.1.2 [Задание 1. Блок stack. Код](#задание-1-блок-stack-код)\
    2.2 [Задание 2. Блок stack. Код](#задание-2-блок-stack-код)
3. [Блок очередей](#блок-очередей)\
    3.1 [Блок очередей. Теория](#блок-очередей-теория)\
    3.2 [Блок очередей. Код](#блок-очередей-код)
4. [Блок hash](#блок-hash)\
    4.1 [Задание 1. Блок hash. Код](#задание-1-блок-hash-код)\
    4.2 [Задание 2. Блок hash. Код](#задание-2-блок-hash-код)\
    4.3 [Задание 3. Блок hash. Код](#задание-3-блок-hash-код)
5. [Блок рекурсия](#блок-рекурсия)\
    5.1 [Блок рекурсия. Теория](#блок-рекурсия-теория)\
    5.2 [Блок рекурсия. Код](#блок-рекурсия-код)
6. [Блок инкапсуляция](#блок-инкапсуляция)\
    6.1 [Задание 1. Блок инкапсуляция. Код](#задание-1-блок-инкапсуляция-код)\
    6.2 [Задание 2. Блок инкапсуляция. Код](#задание-2-блок-инкапсуляция-код)\
    6.3 [Задание 3. Блок инкапсуляция. Код](#задание-3-блок-инкапсуляция-код)\
    6.4 [Задание 4. Блок инкапсуляция. Код](#задание-4-блок-инкапсуляция-код)
7. [Блок наследования](#блок-наследования)\
    7.1 [Блок наследования. Теория](#блок-наследования-теория)\
    7.2 [Блок наследования. Код](#блок-наследования-код)
8. [Блок полиморфизма](#блок-полиморфизма)\
    8.1 [Блок полиморфизма. Теория](#блок-полиморфизма-теория)\
    8.2 [Блок полиморфизма. Код](#блок-полиморфизма-код)

# Блок linked lists

1. Напишите функцию, которая создает пустой связанный список.
2. Напишите функцию, которая добавляет новый узел со значением в начало связанного списка.
3. Напишите функцию, которая добавляет новый узел со значением в конец связанного списка.
4. Напишите тест, который проверяет наличие и удаляет первый узел из связанного списка.
5. Напишите тест, которая проверяет наличие и удаляет все узлы со значением value из связанного списка.

## Задание 1. Блок linked lists. Код

Класс `Node` (Узел):
- `element` - переменная экземпляра класса `Node`, которая содержит значение, хранимое в узле;
- `next` - указатель на следующий узел в списке;
- `Node()` - конструктор класса `Node`.

Класс `LinkedList` (Связанный список):
- `head` - указатель на первый элемент (голову) списка;
- `printErrors` - флаг, используемый для управления выводом сообщений об ошибках;
- `LinkedList()` - конструктор класса `LinkedList`;
- `~LinkedList()` - деструктор класса `LinkedList`;
- `setPrintErrorsFalse()` - функция устанавливает флаг `printErrors` в 0, отключая вывод сообщений об ошибках;
- `setPrintErrorsTrue()` - функция устанавливает флаг `printErrors` в 1, включая вывод сообщений об ошибках;
- `getPrintErrors()` - функция возвращает значение флага `printErrors`;
- `createEmptyLinkedList()` - функция создает и возвращает пустой связанный список;
- `add()` - функция добавляет новый узел со значением data в начало списка;
- `addToEnd()` - функция добавляет новый узел со значением data в конец списка;
- `remove()` - функция удаляет первый элемент из списка и записывает его значение в переменную element;
- `removeByValue()` - функция удаляет первое вхождение значения value из списка;
- `search()` - функция ищет индекс первого вхождения значения element в списке и возвращает его;
- `print()` - функция выводит на экран все элементы списка.

## Задание 2. Блок linked lists. Код

`add()` - функция для добавления нового элемента в начало связанного списка. Функция принимает в качестве аргумента ссылку на константную строку `data`, которая будет хранить значение нового элемента, который мы хотим добавить в список:
- Создается новый узел `Node`, с выделенным для него памятью в куче с помощью оператора new. В этом узле будет храниться значение `data`, переданное в функцию;
- Проверяется, пуст ли список. Если `head` равен nullptr, это означает, что список пустой, и новый узел присваивается `head`. Это происходит, когда список пустой и это первый элемент, который мы добавляем;
- Если список не пустой, новый узел добавляется в начало списка. Указатель `next` нового узла устанавливается на текущий `head`, чтобы он указывал на следующий элемент после добавления нового узла. Затем `head` обновляется, чтобы указывать на новый узел, который теперь становится первым в списке.

## Задание 3. Блок linked lists. Код

`addToEnd()` - функция предназначена для добавления нового элемента в конец связанного списка. Функция принимает в качестве аргумента ссылку на константную строку `data`, которая будет хранить значение нового элемента, который мы хотим добавить в список:
- Создается новый узел `Node`, с выделенным для него памятью в куче с помощью оператора new. В этом узле будет храниться значение `data`, переданное в функцию;
- Проверяется, пуст ли список. Если `head` равен nullptr, это означает, что список пустой, и новый узел присваивается `head`. Это происходит, когда список пустой и это первый элемент, который мы добавляем;
- Если список не пустой, новый узел добавляется в конец списка. Для этого происходит проход по списку до тех пор, пока не будет найден последний узел (т.е. узел, у которого `next` равен nullptr). Когда такой узел найден, его указатель `next` устанавливается на новый узел, добавляя его в конец списка.

## Задание 4. Блок linked lists. Код

`testRemoveFirstNode()` - функция используется для проверки наличия и удаления первого узла из связанного списка. Функция принимает указатель на объект класса `LinkedList` в качестве аргумента и возвращает строку:
- Проверяется, не является ли `head` списка пустым (равным nullptr). Если `head` не является nullptr, это означает, что список не пустой, и операция удаления первого узла может быть выполнена;
- Если список не пустой, сохраняем значение элемента, хранящегося в первом узле списка;
- Вызываем метод `remove()` объекта `myList`, который удаляет первый узел из списка и возвращает значение удаленного элемента через параметр `removedElement`;
- Используется утверждение assert, чтобы проверить, что значение удаленного элемента действительно совпадает с ожидаемым значением, которое мы сохранили ранее. Если значения не совпадают, программа завершается с ошибкой;
- Если удаление прошло успешно и список не был пустым, функция возвращает строку с сообщением о том, что первый элемент удален;
- Если список оказался пустым, функция возвращает строку с сообщением о том, что удаление невозможно, так как список пуст.

## Задание 5. Блок linked lists. Код

`testRemoveValues()`- функция используется для проверки наличия и удаления всех узлов со значением value из связанного списка. Функция принимает указатель на объект класса `LinkedList` и значение `value` в качестве аргументов и возвращает строку:
- Проверяется, не является ли `head` списка пустым (равным nullptr). Если `head` не является nullptr, это означает, что список не пустой, и операция удаления узлов с указанным значением `value` может быть выполнена;
- Вызывается метод `search()` объекта `myList`, который ищет индекс первого узла со значением `value` в списке. Значение индекса сохраняется в `search_result`;
- Устанавливается флаг `printErrors` в false для объекта `myList`, чтобы временно отключить вывод ошибок;
- Затем проверяется, что результат поиска не равен -1, что означает, что узел с искомым значением был найден;
- Если узел с искомым значением не был найден (то есть результат поиска равен -1), функция возвращает сообщение о том, что такой узел не найден, и завершает выполнение;
- Цикл выполняет операцию удаления узлов с заданным значением `value` до тех пор, пока они присутствуют в списке. Когда все узлы с таким значением удалены, функция возвращает сообщение о том, что искомые элементы удалены.
- Если список оказался пустым, функция возвращает сообщение о том, что список пуст.

# Блок stack

1. Реализуйте обратную польскую запись.
2. Реализуйте проверку сбалансированности скобок: стек можно использовать для проверки сбалансированности скобок в строке. При обнаружении открывающейся скобки она добавляется в стек, а при обнаружении закрывающейся скобки она сравнивается с вершиной стека. Если скобки согласованы, они удаляются из стека, иначе возвращается ошибка.

## Задание 1. Блок stack

Реализуйте обратную польскую запись: стек можно использовать для преобразования математического выражения из инфиксной нотации в постфиксную (обратную польскую) запись, а затем для вычисления результата.

## Задание 1. Блок stack. Теория

Постфиксная (или обратная польская) запись арифметического выражения — это способ записи выражений, в котором знак операции записывается не между операндами, а после операндов. Например, сумма чисел 3 и 5 в постфиксной записи записывается так: «3 5 +». Что обозначают более сложные выражение, например, что такое «1 2 3 + +» в постфиксной записи?
Здесь нужно выполнить операцию (2 3 +), ее результатом будет число 5, а потом выполним операцию «1 5 +», где 5 — ранее вычисленное выражение. Тот же пример можно записать и по-другому: «1 2 + 3 +», только порядок действий будет другим — сначала вычисляется «1 2 +», а затем к результату прибавляется число 3.
Постфисная запись является последовательностью действий для стекового калькулятора. Числа добавляются в стек, а результат операций применяется к двум последним числам в стеке, которые из стека удаляются. Затем результат кладется в стек.
То есть выражение «2 3 + 4 *» в постфиксной записи может быть вычислено так:
- Число 2 кладется в стек;
- Число 3 кладется в стек;
- Из стека извлекаются числа 3 и 2, к ним применяется операция сложения, результат (число 5) кладется в стек;
- Число 4 кладется в стек;
- Из стека удаляются числа 5 и 4, результат их умножения 20 кладется в стек.
В итоге в стеке оказывается одно число — 20, которое и есть результат вычисления выражения.

## Задание 1. Блок stack. Код

Класс `StackNode` - класс представляет узел стека:
- `data` - хранит данные типа char;
- `next` - указатель на следующий узел в стеке;
- `StackNode()` - конструктор класса `StackNode`, принимает значение типа char и инициализирует узел с этим значением и указателем `next`, указывающим на nullptr.

Класс `Stack` - класс представляет стек:
- `printErrors` - флаг для управления выводом сообщений об ошибках;
- `size` - хранит размер стека;
- `head` - указатель на вершину стека;
- `Stack()` - конструктор класса `Stack`, инициализирует пустой стек;
- `~Stack()` - деструктор класса `Stack`, освобождает память, выделенную для узлов стека;
- `setPrintErrorsFalse()` - устанавливает флаг `printErrors` в 0;
- `setPrintErrorsTrue()` - устанавливает флаг `printErrors` в 1;
- `getPrintErrors()` - возвращает значение флага `printErrors`;
- `push()` - добавляет новый элемент в вершину стека. Создается новый узел с переданным значением, который становится новой вершиной стека;
- `pop()` - удаляет и возвращает элемент с вершины стека. Если стек пустой, возвращается значение char, представляющее пустой стек. Если стек не пустой, вершина удаляется, и ее значение возвращается.

`task1()` - функция выполняет конкретное задание, связанное с обработкой арифметических выражений:
- Задается инфиксное арифметическое выражение `infixExpression`;
- Выводится инфиксное выражение;
- Выполняется преобразование инфиксного выражения в постфиксное с помощью функции `infixToPostfix()`;
- Выводится постфиксное выражение;
- Выполняется вычисление значения постфиксного выражения с помощью функции `calculatePostfix()`;
- Выводится результат вычисления.

`precedence()` - функция возвращает приоритет оператора:
- `op` - символ оператора;
- Если `op` равен '+' или '-', возвращается 1;
- Если `op` равен '*' или '/', возвращается 2;
- Во всех остальных случаях возвращается 0.

`infixToPostfix()` - функция преобразует инфиксное арифметическое выражение в постфиксное:
- `expression` - инфиксное арифметическое выражение;
- Создается пустая строка `postfix` для хранения постфиксного выражения;
- Создается стек `operators` для хранения операторов;
- Проходится по каждому символу в `expression`;
- Если символ - цифра, он добавляется к `postfix`;
- Если символ - открывающая скобка '(', он помещается в стек `operators`;
- Если символ - закрывающая скобка ')', операторы из стека `operators` извлекаются и добавляются к `postfix` до тех пор, пока не встретится открывающая скобка. Открывающая скобка удаляется из стека `operators`;
- Если символ - оператор, операторы из стека `operators`, чей приоритет больше или равен приоритету текущего оператора, извлекаются и добавляются к `postfix`. Текущий оператор добавляется в стек `operators`;
- Все оставшиеся операторы из стека `operators` добавляются к `postfix`;
- Возвращается `postfix`.

`calculatePostfix()` - функция вычисляет значение постфиксного арифметического выражения:
- `postfix` - постфиксное арифметическое выражение;
- Создается стек `operands` для хранения операндов;
- Проходится по каждому символу в `postfix`;
- Если символ - цифра, он добавляется в стек `operands`;
- Если символ - оператор, извлекаются два операнда из стека `operands`. Выполняется соответствующая операция над операндами в соответствии с оператором;
- Результат операции добавляется в стек `operands`;
- Возвращается результат вычисления, который представляет верхний элемент стека `operands`.

## Задание 2. Блок stack. Код

`task2()` - функция выполняет конкретное задание, связанное с проверкой баланса скобок в последовательности:
- Задается последовательность `sequence`;
- Выводится данная последовательность;
- Вызывается функция `isBalanced()` для проверки баланса скобок в последовательности;
- В зависимости от результата проверки, выводится сообщение о том, сбалансированы ли скобки или нет.

`isBalanced()` - функция проверяет, является ли данная последовательность скобок сбалансированной:
- `sequence` - последовательность скобок для проверки;
- Создается пустой стек `brackets` для хранения скобок;
- Проходится по каждому символу `bracket` в `sequence`;
- Если `bracket` - открывающая скобка '(', '[' или '{', она добавляется в стек `brackets`;
- Если `bracket` - закрывающая скобка ')', ']' или '}', если стек `brackets` пустой, значит, скобки не сбалансированы, и функция возвращает 0. Если верхний элемент стека `brackets` совпадает с соответствующей открывающей скобкой, эта пара скобок считается сбалансированной, и она удаляется из стека `brackets`. В противном случае, скобки не сбалансированы, и функция возвращает 0.
- Если после обработки всей последовательности стек `brackets` остается пустым, это означает, что все скобки были сбалансированы, и функция возвращает 1. В противном случае, возвращается 0.

# Блок очередей

Реализуйте координацию работы множества потоков: очередь может использоваться для координации работы множества потоков, где каждый поток добавляет задачи в очередь, а другие потоки извлекают задачи и выполняют их. Это позволяет эффективно распределить работу между потоками и избежать состояния гонки.

## Блок очередей. Теория

Очередь - это структура данных, которая работает по принципу FIFO (First In, First Out), то есть элементы добавляются в конец очереди, а извлекаются из начала.

Поток - это единица выполнения внутри процесса. Потоки позволяют программе выполнять несколько задач параллельно.

Многопоточность - это подход в программировании, при котором приложение использует несколько потоков для выполнения задач одновременно.

Синхронизация потоков - это методы контроля доступа к общим ресурсам из нескольких потоков для избежания состояния гонки (race condition) и других ошибок, связанных с параллельным выполнением.

Мьютекс (mutex) - это объект синхронизации, который используется для защиты критической секции кода от одновременного доступа из нескольких потоков. Мьютексы обеспечивают монопольный доступ к ресурсу: только один поток может захватить мьютекс в определенный момент времени.

RAII - это идиома программирования в C++, согласно которой управление ресурсами связывается с жизненным циклом объекта. Ресурсы освобождаются автоматически при выходе из области видимости объекта благодаря вызову деструктора объекта.

## Блок очередей. Код

Класс `QueueNode` - представляет узел в очереди:
- `data` - хранит данные типа string;
- `next` - указатель на следующий узел в очереди;
- `QueueNode()` -  конструктор класса `QueueNode`, принимает значение типа string и инициализирует узел с этим значением и указателем `next`, указывающим на nullptr.

Класс `Queue` - представляет очередь:
- `size` - хранит размер очереди;
- `printErrors` - флаг для управления выводом сообщений об ошибках;
- `head` - указатель на начало очереди;
- `tail` - указатель на конец очереди;
- `Queue()` - конструктор класса `Queue`, инициализирует пустую очередь;
- `~Queue()` - деструктор класса `Queue`, освобождает память, выделенную для узлов очереди;
- `setPrintErrorsFalse()` - устанавливает флаг `printErrors` в 0;
- `setPrintErrorsTrue()` - устанавливает флаг `printErrors` в 1;
- `getPrintErrors()` - возвращает значение флага `printErrors`;
- `push()` - добавляет элемент в конец очереди;
- `pop()` - удаляет и возвращает элемент из начала очереди.

`FSS_tasks` - глобальная переменная, представляющая очередь задач для выполнения. Она определена как объект класса `Queue`. В неё добавляются задачи, которые нужно выполнить.

`queueMutex` - объект класса `mutex`, который используется для синхронизации доступа к глобальной очереди `FSS_tasks`. Он блокирует доступ к очереди во время выполнения критических операций, таких как добавление и удаление элементов.

`coutMutex` - это объект класса `mutex`, который используется для синхронизации доступа к стандартному выводу. Он блокирует доступ к cout во время вывода сообщений, чтобы избежать помех от разных потоков.

`main()` - главная функция программы. В этой функции происходит добавление задач в очередь и запуск нескольких потоков для их обработки:
- Добавление задач в глобальную очередь `FSS_tasks`;
- Создание массива потоков `threads` для выполнения задач;
- Запуск потоков, каждый из которых вызывает функцию `processTasks`;
- Ожидание завершения выполнения всех потоков.

`processTasks()` - функция выполняет обработку задач из очереди:
- Захватывается уникальный блокировщик `lock` для объекта `queueMutex`, чтобы предотвратить одновременный доступ к глобальной очереди задач из нескольких потоков;
- Проверяется, не пуста ли очередь `FSS_tasks`;
- Если очередь не пуста, извлекается задача из очереди с помощью функции `pop()`;
- Если очередь пуста, цикл завершается;
- Блокировка `coutMutex` для безопасного вывода сообщения о выполненной задаче в стандартный вывод cout;
- Вывод в стандартный вывод сообщения о том, что задача выполнена текущим потоком с помощью `this_thread::get_id()`;
- Важно заметить, что обе блокировки `queueMutex` и `coutMutex` освобождаются автоматически при выходе из своего области видимости благодаря RAII (Resource Acquisition Is Initialization), что гарантирует безопасное использование мьютексов.

# Блок hash

1. Реализуйте ускорение поиска: хэш-таблицы могут использоваться для эффективного поиска элементов по ключу. Они позволяют получить доступ к элементу за константное время (O(1)), что делает их полезными для реализации словарей, кэшей и других структур данных, где необходим быстрый доступ к данным.
2. Реализуйте устранение дубликатов: хэш-таблицы могут использоваться для удаления дубликатов из набора данных. При добавлении элементов в хэш-таблицу дубликаты будут автоматически игнорироваться, так как они будут иметь одинаковый хэш-код.
3. Реализуйте кэширование: хэш-таблицы могут использоваться для реализации кэшей, где результаты предыдущих вычислений или запросов хранятся в памяти для быстрого доступа. Ключи могут быть параметрами запроса или входными данными, а значения — результатами операций или вычислений.

## Задание 1. Блок hash. Код

Класс `HashTableNode` - представляет узел хэш-таблицы:
- `key` - ключ;
- `element` - значение, связанное с ключом;
- `next` - указатель на следующий узел в цепочке;
- `HashTableNode()` - конструктор класса, принимает ключ `k` и значение `val` и инициализирует соответствующие поля.

Класс `HashTable` - представляет хэш-таблицу:
- `capacity` - емкость (размер) таблицы;
- `size` - текущее количество элементов в таблице;
- `loadThreshold` - пороговое значение нагрузки, определяющее, когда нужно выполнить перехеширование;
- `table` - вектор указателей на узлы, представляющие цепочки элементов;
- `printErrors` - флаг, управляющий выводом сообщений об ошибках;
- `HashTable()` - конструктор класса, принимает начальную емкость `initialCapacity` и коэффициент загрузки `loadFactor` по умолчанию.
- `~HashTable()` - деструктор, освобождает память, выделенную под узлы таблицы;
- `setPrintErrorsFalse()`, `setPrintErrorsTrue()`, `getPrintErrors()` - управление выводом сообщений об ошибках;
- `hash_calc()` - метод для вычисления хэша для заданного ключа;
- `set()` - метод для добавления или обновления пары ключ-значение в таблице;
- `del()` - метод для удаления пары ключ-значение из таблицы;
- `get()` - метод для получения значения по заданному ключу из таблицы;
- `rehash()` - метод для перехеширования таблицы при превышении порогового значения нагрузки.

`get()` метод в классе `HashTable`, предназначен для извлечения значения, связанного с заданным ключом из хэш-таблицы:
- Метод начинается с вычисления хэша для заданного ключа. Это происходит с помощью функции `hash_calc()`. Вычисленный хэш используется для определения индекса в таблице, где, предположительно, находится пара ключ-значение;
- Получив индекс, метод обращается к соответствующему списку (цепочке), хранящемуся в ячейке таблицы с этим индексом;
- Затем производится поиск элемента с заданным ключом в этой цепочке. Метод перебирает узлы в цепочке, начиная с первого, и сравнивает ключ каждого узла с заданным ключом;
- Если в процессе поиска был найден узел с заданным ключом, метод вернет его значение;
- В противном случае, если в цепочке не был найден узел с соответствующим ключом (или цепочка пуста), метод вернет пустую строку, что означает отсутствие значения для данного ключа в таблице;
- В идеальной ситуации, когда хэш-функция распределяет элементы равномерно по ячейкам, длина цепочки остается константой и не зависит от общего количества элементов в таблице. Поэтому поиск по цепочке занимает постоянное время, независимо от размера таблицы. Таким образом, при хорошо спроектированной хэш-функции и правильном управлении коллизиями сложность операции `get()` остается O(1), что делает ее эффективной для поиска элементов в хэш-таблице.

## Задание 2. Блок hash. Код

`set()` - метод в классе `HashTable`, предназначен для добавления или обновления пары ключ-значение в хэш-таблицу:
- Метод начинается с вычисления хэша для заданного ключа с помощью функции `hash_calc()`. Этот хэш определяет индекс в таблице, куда будет добавлен или обновлен элемент;
- Получив индекс, метод проверяет, существует ли уже элемент с таким же ключом в цепочке по этому индексу;
- Если элемент с таким ключом уже существует, значит, имеет место обновление значения для этого ключа. В этом случае метод обновляет значение элемента на новое значение `value` и завершает свою работу. Это предотвращает появление дубликатов, так как для каждого ключа в таблице хранится только одно значение;
- Если элемент с заданным ключом отсутствует в цепочке, метод создает новый узел (объект `HashTableNode`) с указанным ключом и значением `value`;
- Затем этот новый узел добавляется в конец цепочки в соответствующей ячейке таблицы;
- Если цепочка для данного индекса была пуста, новый узел просто станет ее первым элементом;
- Если цепочка не была пуста, новый узел добавляется в конец существующей цепочки;
- После добавления нового элемента метод проверяет, не превышает ли текущая нагрузка таблицы пороговое значение `loadThreshold`;
- Если превышение нагрузки произошло, вызывается метод `rehash()`, который увеличивает емкость таблицы и перехеширует все элементы, чтобы распределить их более равномерно;
- Таким образом, благодаря проверке существующих элементов и предотвращению добавления дубликатов, метод `set()` гарантирует, что для каждого ключа в хэш-таблице будет храниться только одно значение.

## Задание 3. Блок hash. Код

Класс `Cache` представляет собой простую реализацию кэша, который использует хэш-таблицу для хранения и управления кэшированными значениями:
- `hashTable` - это объект типа `HashTable`, который используется для хранения ключей и значений в кэше. Он инкапсулируется в классе `Cache` и используется для управления кэшированными данными;
- `Cache()` - конструктор класса `Cache`, принимает необязательный параметр `capacity`, который определяет начальную емкость хэш-таблицы. Если параметр не указан, емкость по умолчанию устанавливается равной 100. В конструкторе создается объект `HashTable` с заданной емкостью, который инициализируется и сохраняется в приватном поле `hashTable`;
- `addToCache()` - метод, добавляет новое значение в кэш по заданному ключу. Внутри метода вызывается метод `set()` объекта `hashTable`, который добавляет новую пару ключ-значение в хэш-таблицу или обновляет значение, если ключ уже существует;
- `getFromCache()` - метод, возвращает значение из кэша по заданному ключу. Внутри метода вызывается метод `get()` объекта `hashTable`, который извлекает значение из хэш-таблицы по указанному ключу и возвращает его;
- `removeFromCache()` - метод, удаляет значение из кэша по заданному ключу. Внутри метода вызывается метод `del()` объекта `hashTable`, который удаляет пару ключ-значение из хэш-таблицы по указанному ключу.

# Блок рекурсия

Реализуйте задачу комбинаторики согласно предметной области: рекурсия может использоваться для решения задач комбинаторики, таких как генерация всех возможных перестановок, сочетаний или размещений элементов. Рекурсивная функция может вызывать себя для генерации всех комбинаций с уменьшением размера задачи на каждой итерации. Смотреть принцип «Разделяй и властвуй».

## Блок рекурсия. Теория

Рекурсия - это процесс, при котором функция вызывает саму себя внутри своего тела. Она широко используется для решения задач, которые могут быть разбиты на более простые подзадачи. В данном коде функция `generateCombinations()` использует рекурсию для генерации всех возможных комбинаций из заданного набора строк.

## Блок рекурсия. Код

`generateCombinations()` - функция используется для генерации всех возможных комбинаций из заданного набора строк:
- `&FSB` - ссылка на вектор строк, представляющих набор агентств (FSB);
- `k` - целочисленное значение, представляющее размер комбинации;
- `&combination` - ссылка на вектор строк, представляющих текущую комбинацию;
- `start` - целочисленное значение, указывающее начальный индекс для генерации комбинации;
- Рекурсивно генерирует все комбинации, начиная с текущего индекса `start`;
- Для каждого индекса `i` от `start` до конца вектора `FSB`, добавляет соответствующее агентство к текущей комбинации, вызывает себя рекурсивно для генерации остальных элементов комбинации, а затем удаляет добавленный элемент для создания новой комбинации;
- Если размер текущей комбинации становится равным `k`, выводит эту комбинацию на стандартный вывод;
- Когда достигнут конец вектора `FSB` или размер комбинации достигает `k`, функция завершает выполнение текущего шага рекурсии и возвращается к предыдущему вызову.

`main()`:
- В основной функции создается вектор строк `FSB`, который представляет набор агентств ФСБ;
- Задается переменная `n`, которая указывает размер комбинации;
- Создается пустой вектор `combination`, который будет использоваться для хранения текущей комбинации;
- Затем вызывается функция `generateCombinations()` с параметрами `FSB`, `n`, `combination` и 0, чтобы начать генерацию всех комбинаций из агентств ФСБ заданного размера;
- После завершения генерации комбинаций программа завершает свое выполнение, возвращая 0.

# Блок инкапсуляция

1. Создание шаблона класса "Счет": инкапсуляция позволяет скрыть детали реализации и предоставить публичные методы для взаимодействия с объектом "Счет", такие как пополнение, списание и получение баланса.
2. Реализация шаблона класса "Обьект": инкапсуляция позволяет скрыть внутреннюю структуру и состояние объекта, предоставляя публичные методы для доступа к информации объекта (не менее 5).
3. Создание класса "Пользователь": инкапсуляция позволяет скрыть данные о пользователе, такие как логин, пароль и другие конфиденциальные сведения, предоставляя публичные методы для аутентификации, изменения пароля и работы с профилем.
4. Реализация класса "Файловый менеджер": инкапсуляция позволяет скрыть внутренние детали работы с файлами и папками, предоставляя публичные методы для операций, таких как создание, удаление, переименование файлов и папок, а также чтение и запись данных в файлы.

## Задание 1. Блок инкапсуляция. Код

- `task1()`:
- Создает объект класса `Account<float>`, представляющий счет с финансовыми операциями;
- Пополняет счет, выводит информацию о балансе, выполняет списание и снова выводит информацию о балансе счета.

Класс `Account` - представляет счет с атрибутом баланса:
- `deposit()` - метод для пополнения счета на указанную сумму. Он принимает параметр `amount`, который представляет собой сумму для пополнения. Метод увеличивает баланс счета на указанную сумму и выводит сообщение об успешном пополнении;
- `withdraw()` - метод для списания средств со счета. Он принимает параметр `amount`, который представляет собой сумму для списания. Метод проверяет, достаточно ли средств на счете для списания указанной суммы, и при успешном списании уменьшает баланс счета. В случае недостаточности средств выводится сообщение об ошибке;
- `get_balance()` - метод для получения текущего баланса счета. Он возвращает текущее значение баланса;
- `account_balance()` - метод для вывода текущего баланса счета на экран. Он использует метод `get_balance()` для получения текущего баланса и выводит его на стандартный вывод.

## Задание 2. Блок инкапсуляция. Код

`task2()`:
- Создает объекты различных типов с использованием класса `Object`;
- Выполняет операции над данными объектов и выводит информацию о них.

Класс `Object` - представляет объект с атрибутами данных и имени:
- `getData()` - метод для получения данных объекта. Он возвращает текущие данные объекта;
- `setData()` - метод для установки новых данных объекта. Он принимает параметр `new_data`, который представляет собой новые данные, и устанавливает их в объект;
- `getName()` - метод для получения имени объекта. Он возвращает текущее имя объекта;
- `setName()` - метод для установки нового имени объекта. Он принимает параметр `new_name`, который представляет собой новое имя объекта, и устанавливает его;
- `printInfo()` - метод для вывода информации об объекте. Он выводит имя и данные объекта на стандартный вывод;
- `equals()` - метод для проверки равенства данных объекта с другими данными. Он принимает параметр `other_data`, с которым сравниваются данные объекта, и возвращает true, если они равны, и false в противном случае;
- `incrementData()` - метод для увеличения данных объекта на указанную сумму. Он принимает параметр `amount`, на который увеличиваются данные объекта.
- `decrementData()` - метод для уменьшения данных объекта на указанную сумму. Он принимает параметр `amount`, на который уменьшаются данные объекта;
- `resetData()` - метод для сброса данных объекта. Он устанавливает данные объекта в исходное состояние.

## Задание 3. Блок инкапсуляция. Код

`task3()`:
- Создает объект класса `User`, представляющий пользователя;
- Выполняет аутентификацию пользователя, изменение пароля и проверку уровня доступа.

Класс `User` - представляет пользователя с атрибутами имени, пароля и уровня доступа:
- `authenticate()` - метод для аутентификации пользователя. Он принимает имя пользователя `uname` и пароль `pass` и возвращает true, если они соответствуют имени пользователя и паролю объекта пользователя, и false в противном случае;
- `changePassword()` - метод для изменения пароля пользователя. Он принимает старый пароль `oldPass` и новый пароль `newPass` и изменяет пароль пользователя на новый, если старый пароль совпадает с текущим паролем пользователя;
- `getUsername()` - метод для получения имени пользователя. Он возвращает имя пользователя;
- `hasClearance()` - метод для проверки доступа пользователя. Он принимает уровень доступа, требуемый для доступа к конфиденциальной информации, и возвращает true, если у пользователя есть необходимый уровень доступа, и false в противном случае;
- `userProfile()` - метод для вывода профиля пользователя. Он выводит имя пользователя и его уровень доступа на стандартный вывод.

## Задание 4. Блок инкапсуляция. Код

`task4()`:
- Создает объект класса `FileManager`, который выполняет операции с файлами: создание, запись, чтение, переименование и удаление.

Класс `FileManager` - предоставляет методы для работы с файлами, такие как создание, удаление, переименование, запись и чтение:
- `createFile()` - метод для создания файла с указанным именем;
- `deleteFile()` - метод для удаления файла с указанным именем;
- `renameFile()` - метод для переименования файла с указанным именем;
- `writeToFile()` - метод для записи данных в файл с указанным именем. Возвращает true, если запись прошла успешно, и false в противном случае;
- `readFromFile()` - метод для чтения данных из файла с указанным именем. Возвращает содержимое файла в виде строки.

# Блок наследования

Разработайте класс и его подклассы согласно предметной области: наследование позволяет создать базовый класс, от которого можно создать подклассы. Каждый подкласс может иметь свои специфические методы и свойства, а также наследовать общие методы и свойства от базового класса.

## Блок наследования. Теория

Наследование позволяет создавать новый класс на основе существующего (базового) класса. Подкласс (производный класс) наследует атрибуты и методы базового класса. В коде используется наследование для создания специализированных классов сотрудников на основе базового класса `Employee`.

Виртуальные функции обеспечивают динамическое связывание вызова методов во время выполнения программы, что позволяет использовать полиморфизм. В коде в базовом классе `Employee` объявлен виртуальный деструктор для правильного освобождения памяти при удалении объектов через указатель на базовый класс.

## Блок наследования. Код

Класс `Employee` - базовый класс, который представляет общие атрибуты и методы для всех типов сотрудников:
- `name` - имя сотрудника;
- `employeeID` - идентификатор сотрудника;
- `Employee()` - конструктор класса, инициализирующий имя и идентификатор сотрудника;
- `~Employee()` - виртуальный деструктор класса.

Класс `Federal_Security_Servicee` - подкласс от `Employee`, который представляет сотрудников Федеральной службы безопасности:
- `securityLevel` - уровень доступа сотрудника;
- `Federal_Security_Servicee()` - конструктор класса, инициализирующий имя, идентификатор и уровень безопасности сотрудника;
- `doWork()` - выводит информацию о деятельности сотрудника ФСБ;
- `setSecurityLevel()` - устанавливает уровень доступа сотрудника;
- `getSecurityLevel()` - возвращает текущий уровень доступа сотрудника.

Класс `The_Office_of_the_National_AntiTerrorism_Committee` - подкласс от `Employee`, представляющий сотрудников аппарата Национального антитеррористического комитета:
- `numberOfNACPersonnel` - количество персонала в аппарате;
- `The_Office_of_the_National_AntiTerrorism_Committee()` - конструктор класса, инициализирующий имя и идентификатор сотрудника;
- `doWork()` - выводит информацию о деятельности сотрудника НАК;
- `getNumberOfPersonnel()` - возвращает количество персонала в аппарате НАК.

Класс `Service_for_the_Protection_of_the_Constitutional_Order_and_the_Fight_against_Terrorism` - подкласс от `Employee`, представляющий сотрудников Службы по защите конституционного строя и борьбе с терроризмом:
- `director` - руководитель службы;
- `Service_for_the_Protection_of_the_Constitutional_Order_and_the_Fight_against_Terrorism()` - конструктор класса, инициализирующий имя и идентификатор сотрудника;
- `doWork()` - выводит информацию о деятельности сотрудника СЗКСиБТ;
- `printDirector()` - выводит информацию о руководителе службы.

`main()` - главная функция программы:
- создание объектов различных классов;
- вызов общего метода для сотрудников;
- вызов специфических методов для сотрудников.

# Блок полиморфизма

Разработайте механизм позволяющий применять общие методы для различных классов объектов согласно предметной области.

## Блок полиморфизма. Теория

Полиморфизм позволяет объектам различных классов реагировать на одни и те же сообщения или вызовы методов в разных контекстах. Виртуальные функции и функции-члены позволяют использовать полиморфизм в C++. При этом методы, объявленные как виртуальные в базовом классе, могут быть переопределены в производных классах.

Виртуальные функции в C++ используются для достижения полиморфизма. Когда функция объявляется как виртуальная в базовом классе, производные классы могут переопределить эту функцию, предоставляя свою собственную реализацию. Это позволяет объектам производных классов использовать свою собственную версию функции при вызове через указатель или ссылку на базовый класс.

## Блок полиморфизма. Код

Класс `Employee` - класс представляет базового сотрудника:
- `name` - имя сотрудника;
- `employeeID` - идентификационный номер сотрудника;
- `Employee()` - конструктор класса, который инициализирует имя и идентификационный номер сотрудника;
- `doWork()` - виртуальная функция, представляющая работу сотрудника. В данном случае выводит информацию о том, что сотрудник выполняет рабочие обязанности.

Класс `Federal_Security_Servicee` - подкласс, представляющий сотрудника Федеральной службы безопасности:
- `securityLevel` - уровень доступа;
- `doWork()` - переопределенный метод, выводящий информацию о защите разведывательной программы.

Класс `The_Office_of_the_National_AntiTerrorism_Committee` - подкласс, представляющий сотрудника аппарата Национального антитеррористического комитета:
- `doWork()` - переопределенный метод, выводящий информацию о мерах по противодействию терроризму.

Класс `Service_for_the_Protection_of_the_Constitutional_Order_and_the_Fight_against_Terrorism` - подкласс, представляющий сотрудника Службы по защите конституционного строя и борьбе с терроризмом:
- `doWork()` - переопределенный метод, выводящий информацию о мерах по предотвращению угроз и защите конституционного строя.

`performWork()` - общая функция для выполнения работы с сотрудником:
- `emp` - ссылка на объект сотрудника;
- Вызывает виртуальную функцию `doWork()` для переданного объекта сотрудника. Благодаря механизму полиморфизма, будет вызвана соответствующая версия метода в зависимости от типа объекта сотрудника.

`main()` - главная функция программы:
- Создает объекты различных подклассов сотрудников;
- Вызывает функцию `performWork()` для каждого объекта сотрудника.

>
> fratellou, 2024