# Data_structures

Предметная область: Безопасность в сфере государственной службы.

1. Блок linked lists.
2. Блок stack.
3. Блок очередей.
4. Блок hash.
5. Блок рекурсия.
6. Блок инкапсуляция.
7. Блок наследования.
8. Блок полиморфизма.

## Оглавление

1. [Блок linked lists](#блок-linked-lists)\
    1.1 [Задание 1. Блок linked lists. Код](#задание-1-блок-linked-lists-код)\
    1.2 [Задание 2. Блок linked lists. Код](#задание-2-блок-linked-lists-код)\
    1.3 [Задание 3. Блок linked lists. Код](#задание-3-блок-linked-lists-код)\
    1.4 [Задание 4. Блок linked lists. Код](#задание-4-блок-linked-lists-код)\
    1.5 [Задание 5. Блок linked lists. Код](#задание-5-блок-linked-lists-код)
2. [Блок stack](#блок-stack)\
    2.1 [Задание 1. Блок stack](#задание-1-блок-stack)\
        2.1.1 [Задание 1. Блок stack. Теория](#задание-1-блок-stack-теория)\
        2.1.2 [Задание 1. Блок stack. Код](#задание-1-блок-stack-код)\
    2.2 [Задание 2. Блок stack. Код](#задание-2-блок-stack-код)
3. [Блок очередей](#блок-очередей)\
    3.1 [Блок очередей. Теория](#блок-очередей-теория)\
    3.2 [Блок очередей. Код](#блок-очередей-код)
4. [Блок hash](#блок-hash)\
    4.1 [Задание 1. Блок hash. Код](#задание-1-блок-hash-код)\
    4.2 [Задание 2. Блок hash. Код](#задание-2-блок-hash-код)\
    4.3 [Задание 3. Блок hash. Код](#задание-3-блок-hash-код)
5. [Блок рекурсия](#блок-рекурсия)\
    5.1 [Блок рекурсия. Теория](#блок-рекурсия-теория)\
    5.2 [Блок рекурсия. Код](#блок-рекурсия-код)
6. [Блок инкапсуляция](#блок-инкапсуляция)\
    6.1 [Задание 1. Блок инкапсуляция. Код](#задание-1-блок-инкапсуляция-код)\
    6.2 [Задание 2. Блок инкапсуляция. Код](#задание-2-блок-инкапсуляция-код)\
    6.3 [Задание 3. Блок инкапсуляция. Код](#задание-3-блок-инкапсуляция-код)\
    6.4 [Задание 4. Блок инкапсуляция. Код](#задание-4-блок-инкапсуляция-код)
7. [Блок наследования](#блок-наследования)\
    7.1 [Блок наследования. Теория](#блок-наследования-теория)\
    7.2 [Блок наследования. Код](#блок-наследования-код)
8. [Блок полиморфизма](#блок-полиморфизма)\
    8.1 [Блок полиморфизма. Теория](#блок-полиморфизма-теория)\
    8.2 [Блок полиморфизма. Код](#блок-полиморфизма-код)

# Блок linked lists

1. Напишите функцию, которая создает пустой связанный список.
2. Напишите функцию, которая добавляет новый узел со значением в начало связанного списка.
3. Напишите функцию, которая добавляет новый узел со значением в конец связанного списка.
4. Напишите тест, который проверяет наличие и удаляет первый узел из связанного списка.
5. Напишите тест, которая проверяет наличие и удаляет все узлы со значением value из связанного списка.

## Задание 1. Блок linked lists. Код

Класс `Node` (Узел):
- `element` - переменная экземпляра класса `Node`, которая содержит значение, хранимое в узле;
- `next` - указатель на следующий узел в списке;
- `Node()` - конструктор класса `Node`.

Класс `LinkedList` (Связанный список):
- `head` - указатель на первый элемент (голову) списка;
- `printErrors` - флаг, используемый для управления выводом сообщений об ошибках;
- `LinkedList()` - конструктор класса `LinkedList`;
- `~LinkedList()` - деструктор класса `LinkedList`;
- `setPrintErrorsFalse()` - функция устанавливает флаг `printErrors` в 0, отключая вывод сообщений об ошибках;
- `setPrintErrorsTrue()` - функция устанавливает флаг `printErrors` в 1, включая вывод сообщений об ошибках;
- `getPrintErrors()` - функция возвращает значение флага `printErrors`;
- `createEmptyLinkedList()` - функция создает и возвращает пустой связанный список;
- `add()` - функция добавляет новый узел со значением data в начало списка;
- `addToEnd()` - функция добавляет новый узел со значением data в конец списка;
- `remove()` - функция удаляет первый элемент из списка и записывает его значение в переменную element;
- `removeByValue()` - функция удаляет первое вхождение значения value из списка;
- `search()` - функция ищет индекс первого вхождения значения element в списке и возвращает его;
- `print()` - функция выводит на экран все элементы списка;

## Задание 2. Блок linked lists. Код

`add()` - функция для добавления нового элемента в начало связанного списка. Функция принимает в качестве аргумента ссылку на константную строку `data`, которая будет хранить значение нового элемента, который мы хотим добавить в список:
- Создается новый узел `Node`, с выделенным для него памятью в куче с помощью оператора new. В этом узле будет храниться значение `data`, переданное в функцию;
- Проверяется, пуст ли список. Если `head` равен nullptr, это означает, что список пустой, и новый узел присваивается `head`. Это происходит, когда список пустой и это первый элемент, который мы добавляем;
- Если список не пустой, новый узел добавляется в начало списка. Указатель `next` нового узла устанавливается на текущий `head`, чтобы он указывал на следующий элемент после добавления нового узла. Затем `head` обновляется, чтобы указывать на новый узел, который теперь становится первым в списке.

## Задание 3. Блок linked lists. Код


`addToEnd()` - функция предназначена для добавления нового элемента в конец связанного списка. Функция принимает в качестве аргумента ссылку на константную строку `data`, которая будет хранить значение нового элемента, который мы хотим добавить в список:
- Создается новый узел `Node`, с выделенным для него памятью в куче с помощью оператора new. В этом узле будет храниться значение `data`, переданное в функцию;
- Проверяется, пуст ли список. Если `head` равен nullptr, это означает, что список пустой, и новый узел присваивается `head`. Это происходит, когда список пустой и это первый элемент, который мы добавляем;
- Если список не пустой, новый узел добавляется в конец списка. Для этого происходит проход по списку до тех пор, пока не будет найден последний узел (т.е. узел, у которого `next` равен nullptr). Когда такой узел найден, его указатель `next` устанавливается на новый узел, добавляя его в конец списка.

## Задание 4. Блок linked lists. Код

`testRemoveFirstNode()` - функция используется для проверки наличия и удаления первого узла из связанного списка. Функция принимает указатель на объект класса `LinkedList` в качестве аргумента и возвращает строку:
- Проверяется, не является ли `head` списка пустым (равным nullptr). Если `head` не является nullptr, это означает, что список не пустой, и операция удаления первого узла может быть выполнена;
- Если список не пустой, сохраняем значение элемента, хранящегося в первом узле списка;
- Вызываем метод `remove()` объекта `myList`, который удаляет первый узел из списка и возвращает значение удаленного элемента через параметр `removedElement`;
- Используется утверждение assert, чтобы проверить, что значение удаленного элемента действительно совпадает с ожидаемым значением, которое мы сохранили ранее. Если значения не совпадают, программа завершается с ошибкой;
- Если удаление прошло успешно и список не был пустым, функция возвращает строку с сообщением о том, что первый элемент удален;
- Если список оказался пустым, функция возвращает строку с сообщением о том, что удаление невозможно, так как список пуст.

## Задание 5. Блок linked lists. Код

`testRemoveValues()`- функция используется для проверки наличия и удаления всех узлов со значением value из связанного списка. Функция принимает указатель на объект класса `LinkedList` и значение `value` в качестве аргументов и возвращает строку:
- Проверяется, не является ли `head` списка пустым (равным nullptr). Если `head` не является nullptr, это означает, что список не пустой, и операция удаления узлов с указанным значением `value` может быть выполнена;
- Вызывается метод `search()` объекта `myList`, который ищет индекс первого узла со значением `value` в списке. Значение индекса сохраняется в `search_result`;
- Устанавливается флаг `printErrors` в false для объекта `myList`, чтобы временно отключить вывод ошибок;
- Затем проверяется, что результат поиска не равен -1, что означает, что узел с искомым значением был найден;
- Если узел с искомым значением не был найден (то есть результат поиска равен -1), функция возвращает сообщение о том, что такой узел не найден, и завершает выполнение;
- Цикл выполняет операцию удаления узлов с заданным значением `value` до тех пор, пока они присутствуют в списке. Когда все узлы с таким значением удалены, функция возвращает сообщение о том, что искомые элементы удалены.
- Если список оказался пустым, функция возвращает сообщение о том, что список пуст.

# Блок stack

1. Реализуйте обратную польскую запись.
2. Реализуйте проверку сбалансированности скобок: стек можно использовать для проверки сбалансированности скобок в строке. При обнаружении открывающейся скобки она добавляется в стек, а при обнаружении закрывающейся скобки она сравнивается с вершиной стека. Если скобки согласованы, они удаляются из стека, иначе возвращается ошибка.

## Задание 1. Блок stack

Реализуйте обратную польскую запись: стек можно использовать для преобразования математического выражения из инфиксной нотации в постфиксную (обратную польскую) запись, а затем для вычисления результата.

## Задание 1. Блок stack. Теория

Постфиксная (или обратная польская) запись арифметического выражения — это способ записи выражений, в котором знак операции записывается не между операндами, а после операндов. Например, сумма чисел 3 и 5 в постфиксной записи записывается так: «3 5 +». Что обозначают более сложные выражение, например, что такое «1 2 3 + +» в постфиксной записи?
Здесь нужно выполнить операцию (2 3 +), ее результатом будет число 5, а потом выполним операцию «1 5 +», где 5 — ранее вычисленное выражение. Тот же пример можно записать и по-другому: «1 2 + 3 +», только порядок действий будет другим — сначала вычисляется «1 2 +», а затем к результату прибавляется число 3.
Постфисная запись является последовательностью действий для стекового калькулятора. Числа добавляются в стек, а результат операций применяется к двум последним числам в стеке, которые из стека удаляются. Затем результат кладется в стек.
То есть выражение «2 3 + 4 *» в постфиксной записи может быть вычислено так:
- Число 2 кладется в стек;
- Число 3 кладется в стек;
- Из стека извлекаются числа 3 и 2, к ним применяется операция сложения, результат (число 5) кладется в стек;
- Число 4 кладется в стек;
- Из стека удаляются числа 5 и 4, результат их умножения 20 кладется в стек.
В итоге в стеке оказывается одно число — 20, которое и есть результат вычисления выражения.

## Задание 1. Блок stack. Код

Класс `StackNode` - класс представляет узел стека:
- `data` - хранит данные типа char;
- `next` - указатель на следующий узел в стеке;
- `StackNode()` - конструктор класса `StackNode`, принимает значение типа char и инициализирует узел с этим значением и указателем `next`, указывающим на nullptr.

Класс `Stack` - класс представляет стек:
- `printErrors` - флаг для управления выводом сообщений об ошибках;
- `size` - хранит размер стека;
- `head` - указатель на вершину стека;
- `Stack()` - конструктор класса `Stack`, инициализирует пустой стек;
- `~Stack()` - деструктор класса `Stack`, освобождает память, выделенную для узлов стека;
- `setPrintErrorsFalse()` - устанавливает флаг `printErrors` в 0;
- `setPrintErrorsTrue()` - устанавливает флаг `printErrors` в 1;
- `getPrintErrors()` - возвращает значение флага `printErrors`;
- `push()` - добавляет новый элемент в вершину стека. Создается новый узел с переданным значением, который становится новой вершиной стека;
- `pop()` - удаляет и возвращает элемент с вершины стека. Если стек пустой, возвращается значение char, представляющее пустой стек. Если стек не пустой, вершина удаляется, и ее значение возвращается.

Функция task1()
Описание: Функция выполняет конкретное задание, связанное с обработкой арифметических выражений.

Действия:

Задается инфиксное арифметическое выражение infixExpression.
Выводится инфиксное выражение.
Выполняется преобразование инфиксного выражения в постфиксное с помощью функции infixToPostfix.
Выводится постфиксное выражение.
Выполняется вычисление значения постфиксного выражения с помощью функции calculatePostfix.
Выводится результат вычисления.
Функция precedence(char op)
Описание: Функция возвращает приоритет оператора.

Параметры:

op: Символ оператора.
Действия:

Если op равен '+' или '-', возвращается 1.
Если op равен '*' или '/', возвращается 2.
Во всех остальных случаях возвращается 0.
Функция infixToPostfix(const string& expression)
Описание: Функция преобразует инфиксное арифметическое выражение в постфиксное.

Параметры:

expression: Инфиксное арифметическое выражение.
Действия:

Создается пустая строка postfix для хранения постфиксного выражения.
Создается стек operators для хранения операторов.
Проходится по каждому символу в expression:
Если символ - цифра, он добавляется к postfix.
Если символ - открывающая скобка '(', он помещается в стек operators.
Если символ - закрывающая скобка ')':
Операторы из стека operators извлекаются и добавляются к postfix до тех пор, пока не встретится открывающая скобка.
Открывающая скобка удаляется из стека operators.
Если символ - оператор:
Операторы из стека operators, чей приоритет больше или равен приоритету текущего оператора, извлекаются и добавляются к postfix.
Текущий оператор добавляется в стек operators.
Все оставшиеся операторы из стека operators добавляются к postfix.
Возвращается postfix.
Функция calculatePostfix(const string& postfix)
Описание: Функция вычисляет значение постфиксного арифметического выражения.

Параметры:

postfix: Постфиксное арифметическое выражение.
Действия:

Создается стек operands для хранения операндов.
Проходится по каждому символу в postfix:
Если символ - цифра, он добавляется в стек operands.
Если символ - оператор:
Извлекаются два операнда из стека operands.
Выполняется соответствующая операция над операндами в соответствии с оператором.
Результат операции добавляется в стек operands.
Возвращается результат вычисления, который представляет верхний элемент стека operands.

## Задание 2. Блок stack. Код

# Блок очередей

Реализуйте координацию работы множества потоков: очередь может
использоваться для координации работы множества потоков, где каждый поток
добавляет задачи в очередь, а другие потоки извлекают задачи и выполняют их.
Это позволяет эффективно распределить работу между потоками и избежать
состояния гонки.

## Блок очередей. Теория
## Блок очередей. Код

# Блок hash

1. Реализуйте ускорение поиска: хэш-таблицы могут использоваться для
эффективного поиска элементов по ключу. Они позволяют получить доступ к
элементу за константное время (O(1)), что делает их полезными для реализации
словарей, кэшей и других структур данных, где необходим быстрый доступ к
данным.
2. Реализуйте устранение дубликатов: хэш-таблицы могут использоваться для
удаления дубликатов из набора данных. При добавлении элементов в хэш-таблицу
дубликаты будут автоматически игнорироваться, так как они будут иметь
одинаковый хэш-код.
3. Реализуйте кэширование: хэш-таблицы могут использоваться для реализации
кэшей, где результаты предыдущих вычислений или запросов хранятся в памяти
для быстрого доступа. Ключи могут быть параметрами запроса или входными
данными, а значения — результатами операций или вычислений.

## Задание 1. Блок hash. Код
## Задание 2. Блок hash. Код
## Задание 3. Блок hash. Код

# Блок рекурсия

Реализуйте задачу комбинаторики согласно предметной области: рекурсия может
использоваться для решения задач комбинаторики, таких как генерация всех
возможных перестановок, сочетаний или размещений элементов. Рекурсивная
функция может вызывать себя для генерации всех комбинаций с уменьшением
размера задачи на каждой итерации. Смотреть принцип «Разделяй и властвуй».

## Блок рекурсия. Теория
## Блок рекурсия. Код

# Блок инкапсуляция

1. Создание шаблона класса "Счет": инкапсуляция позволяет скрыть детали
реализации и предоставить публичные методы для взаимодействия с объектом
"Счет", такие как пополнение, списание и получение баланса.
2. Реализация шаблона класса "Обьект": инкапсуляция позволяет скрыть внутреннюю
структуру и состояние объекта, предоставляя публичные методы для доступа к
информации объекта (не менее 5).
3. Создание класса "Пользователь": инкапсуляция позволяет скрыть данные о
пользователе, такие как логин, пароль и другие конфиденциальные сведения,
предоставляя публичные методы для аутентификации, изменения пароля и работы
с профилем.
4. Реализация класса "Файловый менеджер": инкапсуляция позволяет скрыть
внутренние детали работы с файлами и папками, предоставляя публичные методы
для операций, таких как создание, удаление, переименование файлов и папок, а
также чтение и запись данных в файлы.

## Задание 1. Блок инкапсуляция. Код
## Задание 2. Блок инкапсуляция. Код
## Задание 3. Блок инкапсуляция. Код
## Задание 4. Блок инкапсуляция. Код

# Блок наследования

Разработайте класс и его подклассы согласно предметной области: наследование
позволяет создать базовый класс, от которого можно создать подклассы. Каждый
подкласс может иметь свои специфические методы и свойства, а также
наследовать общие методы и свойства от базового класса.

## Блок наследования. Теория
## Блок наследования. Код

# Блок полиморфизма

Разработайте механизм позволяющий применять общие методы для различных
классов объектов согласно предметной области.

## Блок полиморфизма. Теория
## Блок полиморфизма. Код